---
title: Express 5.x - API Reference
---

:::caution
This is early beta documentation that may be incomplete and is still under development.
:::

:::caution
Express 5.0 requires Node.js 18 or higher.
:::

## Application

The `app` object conventionally denotes the Express application.
Create it by calling the top-level `express()` function exported by the Express module:

```js
const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
```

The `app` object has methods for

* Routing HTTP requests; see for example, [app.METHOD](#app.METHOD) and [app.param](#app.param).
* Configuring middleware; see [app.route](#app.route).
* Rendering HTML views; see [app.render](#app.render).
* Registering a template engine; see [app.engine](#app.engine).

It also has settings (properties) that affect how the application behaves;
for more information, see [Application settings](#app.settings.table).

:::note
The Express application object can be referred from the [request object](#req) and the [response object](#res) as `req.app`, and `res.app`, respectively.
:::

### Properties

<section markdown="1">
#### app.locals

The `app.locals` object has properties that are local variables within the application,
and will be available in templates rendered with [res.render](#res.render).

```js
console.dir(app.locals.title)
// => 'My App'

console.dir(app.locals.email)
// => 'me@myapp.com'
```

Once set, the value of `app.locals` properties persist throughout the life of the application,
in contrast with [res.locals](#res.locals) properties that
are valid only for the lifetime of the request.

You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via `req.app.locals` (see [req.app](#req.app))

```js
app.locals.title = 'My App'
app.locals.strftime = require('strftime')
app.locals.email = 'me@myapp.com'
```

</section>

<section markdown="1">
#### app.mountpath

The `app.mountpath` property contains one or more path patterns on which a sub-app was mounted.

:::note
  A sub-app is an instance of `express` that may be used for handling the request to a route.
:::

```js
const express = require('express')

const app = express() // the main app
const admin = express() // the sub app

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // /admin
  res.send('Admin Homepage')
})

app.use('/admin', admin) // mount the sub app
```

It is similar to the [baseUrl](#req.baseUrl) property of the `req` object, except `req.baseUrl`
returns the matched URL path, instead of the matched patterns.

If a sub-app is mounted on multiple path patterns, `app.mountpath` returns the list of
patterns it is mounted on, as shown in the following example.

```js
const admin = express()

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // [ '/adm*n', '/manager' ]
  res.send('Admin Homepage')
})

const secret = express()
secret.get('/', (req, res) => {
  console.log(secret.mountpath) // /secr*t
  res.send('Admin Secret')
})

admin.use('/secr*t', secret) // load the 'secret' router on '/secr*t', on the 'admin' sub app
app.use(['/adm*n', '/manager'], admin) // load the 'admin' router on '/adm*n' and '/manager', on the parent app
```

</section>

<section markdown="1">
#### app.router

The application's in-built instance of router. This is created lazily, on first access.

```js
const express = require('express')
const app = express()
const router = app.router

router.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
```

You can add middleware and HTTP method routes to the `router` just like an application.

For more information, see [Router](#router).

</section>

### Events

<section markdown="1">
#### app.on('mount', callback(parent))

The `mount` event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

:::note
Sub-apps will:

* Not inherit the value of settings that have a default value. You must set the value in the sub-app.
* Inherit the value of settings with no default value.

For details, see [Application settings](/en/5x/api.html#app.settings.table).
:::

```js
const admin = express()

admin.on('mount', (parent) => {
  console.log('Admin Mounted')
  console.log(parent) // refers to the parent app
})

admin.get('/', (req, res) => {
  res.send('Admin Homepage')
})

app.use('/admin', admin)
```

</section>

### Methods

<section markdown="1">
#### app.all(path, callback [, callback ...])

This method is like the standard [app.METHOD()](#app.METHOD) methods,
except it matches all HTTP verbs.

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Examples

The following callback is executed for requests to `/secret` whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

```js
app.all('/secret', (req, res, next) => {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
```

The `app.all()` method is useful for mapping "global" logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: `loadUser`
can perform a task, then call `next()` to continue matching subsequent
routes.

```js
app.all('*', requireAuthentication, loadUser)
```

Or the equivalent:

```js
app.all('*', requireAuthentication)
app.all('*', loadUser)
```

Another example is white-listed "global" functionality.
The example is similar to the ones above, but it only restricts paths that start with
"/api":

```js
app.all('/api/*', requireAuthentication)
```

</section>

<section markdown="1">
#### app.delete(path, callback [, callback ...])

Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the [routing guide](/{{page.lang}}/guide/routing.html).

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Example

```js
app.delete('/', (req, res) => {
  res.send('DELETE request to homepage')
})
```

</section>

<section markdown="1">
#### app.disable(name)

Sets the Boolean setting `name` to `false`, where `name` is one of the properties from the [app settings table](#app.settings.table).
Calling `app.set('foo', false)` for a Boolean property is the same as calling `app.disable('foo')`.

For example:

```js
app.disable('trust proxy')
app.get('trust proxy')
// => false
```

</section>

<section markdown="1">
#### app.disabled(name)

Returns `true` if the Boolean setting `name` is disabled (`false`), where `name` is one of the properties from
the [app settings table](#app.settings.table).

```js
app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
```

</section>

<section markdown="1">
#### app.enable(name)

Sets the Boolean setting `name` to `true`, where `name` is one of the properties from the [app settings table](#app.settings.table).
Calling `app.set('foo', true)` for a Boolean property is the same as calling `app.enable('foo')`.

```js
app.enable('trust proxy')
app.get('trust proxy')
// => true
```

</section>

<section markdown="1">
#### app.enabled(name)

Returns `true` if the setting `name` is enabled (`true`), where `name` is one of the
properties from the [app settings table](#app.settings.table).

```js
app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
```

</section>

<section markdown="1">
#### app.engine(ext, callback)

Registers the given template engine `callback` as `ext`.

By default, Express will `require()` the engine based on the file extension.
For example, if you try to render a "foo.pug" file, Express invokes the
following internally, and caches the `require()` on subsequent calls to increase
performance.

```js
app.engine('pug', require('pug').__express)
```

Use this method for engines that do not provide `.__express` out of the box,
or if you wish to "map" a different extension to the template engine.

For example, to map the EJS template engine to ".html" files:

```js
app.engine('html', require('ejs').renderFile)
```

In this case, EJS provides a `.renderFile()` method with
the same signature that Express expects: `(path, options, callback)`,
though note that it aliases this method as `ejs.__express` internally
so if you're using ".ejs" extensions you don't need to do anything.

Some template engines do not follow this convention.  The
[consolidate.js](https://github.com/tj/consolidate.js) library maps Node template engines to follow this convention,
so they work seamlessly with Express.

```js
const engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
```

</section>

<section markdown="1">
#### app.get(name)

Returns the value of `name` app setting, where `name` is one of the strings in the
[app settings table](#app.settings.table). For example:

```js
app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
```

</section>

<section markdown="1">
#### app.get(path, callback [, callback ...])

Routes HTTP GET requests to the specified path with the specified callback functions.

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


For more information, see the [routing guide](/{{page.lang}}/guide/routing.html).

##### Example

```js
app.get('/', (req, res) => {
  res.send('GET request to homepage')
})
```

</section>

<section markdown="1">
#### app.listen(path, [callback])

Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node's [http.Server.listen()](https://nodejs.org/api/http.html#http_server_listen).

```js
const express = require('express')
const app = express()
app.listen('/tmp/sock')
```

#### app.listen([port[, host[, backlog]]][, callback])

Binds and listens for connections on the specified host and port.
This method is identical to Node's [http.Server.listen()](https://nodejs.org/api/http.html#http_server_listen).

If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

```js
const express = require('express')
const app = express()
app.listen(3000)
```

The `app` returned by `express()` is in fact a JavaScript
`Function`, designed to be passed to Node's HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

```js
const express = require('express')
const https = require('https')
const http = require('http')
const app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
```

The `app.listen()` method returns an [http.Server](https://nodejs.org/api/http.html#http_class_http_server) object and (for HTTP) is a convenience method for the following:

```js
app.listen = function () {
  const server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
```

:::note
All the forms of Node's
[http.Server.listen()](https://nodejs.org/api/http.html#http_server_listen)
method are in fact actually supported.
:::

</section>

<section markdown="1">
#### app.METHOD(path, callback [, callback ...])

Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are `app.get()`,
`app.post()`, `app.put()`, and so on. See [Routing methods](#routing-methods) below for the complete list.

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Routing methods

Express supports the following routing methods corresponding to the HTTP methods of the same names:

<table style="border: 0px; background: none">
<tr>
<td style="background: none; border: 0px;" markdown="1">
* `checkout`
* `copy`
* `delete`
* `get`
* `head`
* `lock`
* `merge`
* `mkactivity`
</td>
<td style="background: none; border: 0px;" markdown="1">
* `mkcol`
* `move`
* `m-search`
* `notify`
* `options`
* `patch`
* `post`
</td>
<td style="background: none; border: 0px;" markdown="1">
* `purge`
* `put`
* `report`
* `search`
* `subscribe`
* `trace`
* `unlock`
* `unsubscribe`
</td>
</tr>
</table>

The API documentation has explicit entries only for the most popular HTTP methods `app.get()`,
`app.post()`, `app.put()`, and `app.delete()`.
However, the other methods listed above work in exactly the same way.

To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, `app['m-search']('/', function ...`.

:::note
  The `app.get()` function is automatically called for the HTTP `HEAD` method in addition to the `GET`
  method if `app.head()` was not called for the path before `app.get()`.
:::

The method, `app.all()`, is not derived from any HTTP method and loads middleware at
the specified path for _all_ HTTP request methods.
For more information, see [app.all](#app.all).

For more information on routing, see the [routing guide](/{{page.lang}}/guide/routing.html).

</section>

<section markdown="1">
#### app.param(name, callback)

Add callback triggers to [route parameters](/guide/routing.html#route-parameters), where `name` is the name of the parameter or an array of them, and `callback` is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

If `name` is an array, the `callback` trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to `next` inside the callback will call the callback for the next declared parameter. For the last parameter, a call to `next` will call the next middleware in place for the route currently being processed, just like it would if `name` were just a string.

For example, when `:user` is present in a route path, you may map user loading logic to automatically provide `req.user` to the route, or perform validations on the parameter input.

```js
app.param('user', (req, res, next, id) => {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, (err, user) => {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
```

Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on `app` will be triggered only by route parameters defined on `app` routes.

All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

```js
app.param('id', (req, res, next, id) => {
  console.log('CALLED ONLY ONCE')
  next()
})

app.get('/user/:id', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id', (req, res) => {
  console.log('and this matches too')
  res.end()
})
```

On `GET /user/42`, the following is printed:

```
CALLED ONLY ONCE
although this matches
and this matches too
```

```js
app.param(['id', 'page'], (req, res, next, value) => {
  console.log('CALLED ONLY ONCE with', value)
  next()
})

app.get('/user/:id/:page', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id/:page', (req, res) => {
  console.log('and this matches too')
  res.end()
})
```

On `GET /user/42/3`, the following is printed:

```
CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
```

</section>

<section markdown="1">
#### app.path()

Returns the canonical path of the app, a string.

```js
const app = express()
const blog = express()
const blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.log(app.path()) // ''
console.log(blog.path()) // '/blog'
console.log(blogAdmin.path()) // '/blog/admin'
```

The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use [req.baseUrl](#req.baseUrl) to get the canonical path of the app.

</section>

<section markdown="1">
#### app.post(path, callback [, callback ...])

Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the [routing guide](/{{page.lang}}/guide/routing.html).

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Example

```js
app.post('/', (req, res) => {
  res.send('POST request to homepage')
})
```

</section>

<section markdown="1">
#### app.put(path, callback [, callback ...])

Routes HTTP PUT requests to the specified path with the specified callback functions.

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Example

```js
app.put('/', (req, res) => {
  res.send('PUT request to homepage')
})
```

</section>

<section markdown="1">
#### app.render(view, [locals], callback)

Returns the rendered HTML of a view via the `callback` function. It accepts an optional parameter
that is an object containing local variables for the view. It is like [res.render()](#res.render),
except it cannot send the rendered view to the client on its own.

:::note
Think of `app.render()` as a utility function for generating rendered view strings.
Internally `res.render()` uses `app.render()` to render views.
:::

:::caution
The local variable `cache` is reserved for enabling view cache. Set it to `true`, if you want to
cache view during development; view caching is enabled in production by default.
:::

```js
app.render('email', (err, html) => {
  // ...
})

app.render('email', { name: 'Tobi' }, (err, html) => {
  // ...
})
```

</section>

<section markdown="1">
#### app.route(path)

Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use `app.route()` to avoid duplicate route names (and thus typo errors).

```js
const app = express()

app.route('/events')
  .all((req, res, next) => {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
  })
  .get((req, res, next) => {
    res.json({})
  })
  .post((req, res, next) => {
    // maybe add a new event...
  })
```

</section>

<section markdown="1">
#### app.set(name, value)

Assigns setting `name` to `value`. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the [app settings table](#app.settings.table).

Calling `app.set('foo', true)` for a Boolean property is the same as calling
`app.enable('foo')`. Similarly, calling `app.set('foo', false)` for a Boolean
property is the same as calling `app.disable('foo')`.

Retrieve the value of a setting with [`app.get()`](#app.get).

```js
app.set('title', 'My Site')
app.get('title') // "My Site"
```

##### Application Settings

The following table lists application settings.

Note that sub-apps will:

* Not inherit the value of settings that have a default value. You must set the value in the sub-app.
* Inherit the value of settings with no default value; these are explicitly noted in the table below.

Exceptions: Sub-apps will inherit the value of `trust proxy` even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of `view cache` in production (when `NODE_ENV` is "production").

<div class="table-scroller">
  <table class="doctable" border="1">
    <thead><tr><th id="app-settings-property">Property</th><th>Type</th><th>Description</th><th>Default</th></tr></thead>
    <tbody>
    <tr>
  <td markdown="1">
  `case sensitive routing`
  </td>
      <td>Boolean</td>
      <td>
      <p>Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.</p>
:::note
       Sub-apps will inherit the value of this setting.
:::
      </td>
      <td>
      N/A (undefined)
      </td>
    </tr>
    <tr>
  <td markdown="1">
  `env`
  </td>
      <td>String</td>
      <td>
      Environment mode.
      Be sure to set to "production" in a production environment;
      see <a href="/advanced/best-practice-performance.html#env">Production best practices: performance and reliability</a>.
    </td>
  <td markdown="1">
  `process.env.NODE_ENV` (`NODE_ENV` environment variable) or "development" if `NODE_ENV` is not set.
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `etag`
  </td>
  <td>Varied</td>
  <td markdown="1">
  Set the ETag response header. For possible values, see the [`etag` options table](#etag.options.table).

  [More about the HTTP ETag header](http://en.wikipedia.org/wiki/HTTP_ETag).
  </td>
  <td markdown="1">
  `weak`
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `jsonp callback name`
  </td>
      <td>String</td>
      <td>Specifies the default JSONP callback name.</td>
  <td markdown="1">
  "callback"
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `json escape`
  </td>
  <td>Boolean</td>
  <td markdown="1">
  Enable escaping JSON responses from the `res.json`, `res.jsonp`, and `res.send` APIs. This will escape the characters `<`, `>`, and `&` as Unicode escape sequences in JSON. The purpose of this is to assist with [mitigating certain types of persistent XSS attacks](https://blog.mozilla.org/security/2017/07/18/web-service-audits-firefox-accounts/) when clients sniff responses for HTML.
:::note
 Sub-apps will inherit the value of this setting.
:::
  </td>
  <td>N/A (undefined)</td>
    </tr>
    <tr>
  <td markdown="1">
  `json replacer`
  </td>
      <td>Varied</td>
      <td>
      The <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">'replacer' argument used by `JSON.stringify`</a>.
:::note
 Sub-apps will inherit the value of this setting.
:::
      </td>
  <td>
  N/A (undefined)
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `json spaces`
  </td>
      <td>Varied</td>
      <td>
      The <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_space_argument">'space' argument used by `JSON.stringify`</a>.
This is typically set to the number of spaces to use to indent prettified JSON.
:::note
 Sub-apps will inherit the value of this setting.
:::
      </td>
      <td>N/A (undefined)</td>
    </tr>
    <tr>
  <td markdown="1">
  `query parser`
  </td>
      <td>Varied</td>
  <td markdown="1">
Disable query parsing by setting the value to `false`, or set the query parser to use either "simple" or "extended" or a custom query string parsing function.

The simple query parser is based on Node's native query parser, [querystring](http://nodejs.org/api/querystring.html).

The extended query parser is based on [qs](https://www.npmjs.org/package/qs).

A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.
  </td>
      <td>"simple"</td>
    </tr>
    <tr>
  <td markdown="1">
  `strict routing`
  </td>
      <td>Boolean</td>
      <td>
      <p>Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.</p>
:::note
  Sub-apps will inherit the value of this setting.
:::
      </td>
      <td>N/A (undefined) </td>
    </tr>
    <tr>
  <td markdown="1">
  `subdomain offset`
  </td>
      <td>Number</td>
      <td>The number of dot-separated parts of the host to remove to access subdomain.</td>
      <td>2</td>
    </tr>
    <tr>
  <td markdown="1">
  `trust proxy`
  </td>
      <td>Varied</td>
  <td markdown="1">
  Indicates the app is behind a front-facing proxy, and to use the `X-Forwarded-*` headers to determine the connection and the IP address of the client. NOTE: `X-Forwarded-*` headers are easily spoofed and the detected IP addresses are unreliable.
<p>
  When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the <a href="#trust.proxy.options.table">trust proxy options table</a>.
</p><p>
  The `trust proxy` setting is implemented using the <a href="https://www.npmjs.org/package/proxy-addr">proxy-addr</a> package. For more information, see its documentation.
</p>
:::note
 Sub-apps <i>will</i> inherit the value of this setting, even though it has a default value.
:::
  </td>
  <td markdown="1">
  `false` (disabled)
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `views`
  </td>
      <td>String or Array</td>
      <td>A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.</td>
  <td markdown="1">
  `process.cwd() + '/views'`
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `view cache`
  </td>
      <td>Boolean</td>
      <td>
      <p>Enables view template compilation caching.</p>
:::note
Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").
:::
      </td>
  <td markdown="1">
  `true` in production, otherwise undefined.
  </td>
    </tr>
    <tr>
  <td markdown="1">
  `view engine`
  </td>
      <td>String</td>
      <td>
      <p>The default engine extension to use when omitted.</p>
:::note 
 Sub-apps will inherit the value of this setting.
:::
      </td>
      <td>N/A (undefined)</td>
    </tr>
    <tr>
  <td markdown="1">
  `x-powered-by`
  </td>
      <td>Boolean</td>
      <td>Enables the "X-Powered-By: Express" HTTP header.</td>
  <td markdown="1">
  `true`
  </td>
    </tr>
    </tbody>
  </table>

###### Options for `trust proxy` setting

  <p markdown="1">
  Read [Express behind proxies](/guide/behind-proxies.html) for more
  information.
  </p>

  <table class="doctable">
    <thead><tr><th>Type</th><th>Value</th></tr></thead>
    <tbody>
      <tr>
        <td>Boolean</td>
  <td markdown="1">
  If `true`, the client's IP address is understood as the left-most entry in the `X-Forwarded-*` header.

  If `false`, the app is understood as directly facing the Internet and the client's IP address is derived from `req.connection.remoteAddress`. This is the default setting.
  </td>
      </tr>
      <tr>
        <td>String<br/>String containing comma-separated values<br/>Array of strings </td>
  <td markdown="1">
  An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

  * loopback - `127.0.0.1/8`, `::1/128`
  * linklocal - `169.254.0.0/16`, `fe80::/10`
  * uniquelocal - `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, `fc00::/7`

  Set IP addresses in any of the following ways:

Specify a single subnet:

```js
app.set('trust proxy', 'loopback')
```

Specify a subnet and an address:

```js
app.set('trust proxy', 'loopback, 123.123.123.123')
```

Specify multiple subnets as CSV:

```js
app.set('trust proxy', 'loopback, linklocal, uniquelocal')
```

Specify multiple subnets as an array:

```js
app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
```

  When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client's IP address.
  </td>
      </tr>
      <tr>
        <td>Number</td>
  <td markdown="1">
  Trust the <i>n</i><sup>th</sup> hop from the front-facing proxy server as the client.
  </td>
      </tr>
      <tr>
        <td>Function</td>
  <td markdown="1">
  Custom trust implementation. Use this only if you know what you are doing.

```js
app.set('trust proxy', (ip) => {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
```
  </td>
      </tr>
    </tbody>
  </table>

###### Options for `etag` setting

:::note
These settings apply only to dynamic files, not static files.
The [express.static](#express.static) middleware ignores these settings.
:::

  <p markdown="1">
  The ETag functionality is implemented using the
  [etag](https://www.npmjs.org/package/etag) package.
  For more information, see its documentation.
  </p>

  <table class="doctable" border="1">
    <thead><tr><th>Type</th><th>Value</th></tr></thead>
    <tbody>
      <tr>
        <td>Boolean</td>
  <td markdown="1">
  `true` enables weak ETag. This is the default setting.
  <br/>
  `false` disables ETag altogether.
  </td>
      </tr>
      <tr>
        <td>String</td>
        <td>
            If "strong", enables strong ETag.<br/>
            If "weak", enables weak ETag.
        </td>
      </tr>
      <tr>
        <td>Function</td>
  <td markdown="1">
  Custom ETag function implementation. Use this only if you know what you are doing.

```js
app.set('etag', (body, encoding) => {
  return generateHash(body, encoding) // consider the function is defined
})
```
  </td>
      </tr>
    </tbody>
  </table>
</div>


</section>

<section markdown="1">
#### app.use([path,] callback [, callback...])

Mounts the specified [middleware](/{{page.lang}}/guide/using-middleware.html) function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches `path`.

##### Arguments

<table class="doctable">
<tr>
<th>Argument </th>
<th> Description </th>
<th style="width: 100px;"> Default </th>
</tr>

<tr>
<td><code>path</code></td>
<td>
The path for which the middleware function is invoked; can be any of:
<ul>
<li>A string representing a path.</li>
<li>A path pattern.</li>
<li>A regular expression pattern to match paths.</li>
<li>An array of combinations of any of the above.</li>
</ul>

For examples, see <a href="#path-examples">Path examples</a>.
</td>
<td>'/' (root path)</td>
</tr>

<tr>
<td> <code>callback</code></td>
<td>
Callback functions; can be:
<ul>
<li>A middleware function.</li>
<li>A series of middleware functions (separated by commas).</li>
<li>An array of middleware functions.</li>
<li>A combination of all of the above.</li>
</ul>
<p>
You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke <code>next('route')</code> to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.
</p><p>
When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.
</p><p>
Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface,
you can use them as you would any other middleware function.
</p><p>
For examples, see <a href="#middleware-callback-function-examples">Middleware callback function examples</a>.
</p>
</td>
<td> None </td>
</tr></table>


##### Description

A route will match any path that follows its path immediately with a "`/`".
For example: `app.use('/apple', ...)` will match "/apple", "/apple/images",
"/apple/images/news", and so on.

Since `path` defaults to "/", middleware mounted without a path will be executed for every request to the app.  
For example, this middleware function will be executed for _every_ request to the app:

```js
app.use((req, res, next) => {
  console.log('Time: %d', Date.now())
  next()
})
```

:::note
Sub-apps will:

* Not inherit the value of settings that have a default value. You must set the value in the sub-app.
* Inherit the value of settings with no default value.

For details, see [Application settings](/en/5x/api.html#app.settings.table).
:::

Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

```js
// this middleware will not allow the request to go beyond it
app.use((req, res, next) => {
  res.send('Hello World')
})

// requests will never reach this route
app.get('/', (req, res) => {
  res.send('Welcome')
})
```

**Error-handling middleware**

Error-handling middleware always takes _four_ arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don't need to use the `next` object, you must specify it to maintain the signature. Otherwise, the `next` object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: [Error handling](/guide/error-handling.html).

Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature `(err, req, res, next)`):

```js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
```

##### Path examples

The following table provides some simple examples of valid `path` values for
mounting middleware.

<div class="table-scroller">
<table class="doctable" border="1">

<thead>
<tr>
<th>Type</th>
<th>Example</th>
</tr>
</thead>

<tbody>

<tr>
<td>Path</td>
<td markdown="1">
This will match paths starting with `/abcd`:

```js
app.use('/abcd', (req, res, next) => {
  next()
})
```

</td>
</tr>

<tr>
<td>Path Pattern</td>
<td markdown="1">
This will match paths starting with `/abcd` and `/abd`:

```js
app.use('/ab(c?)d', (req, res, next) => {
  next()
})
```

</td>
</tr>

<tr>
<td>Regular Expression</td>
<td markdown="1">
This will match paths starting with `/abc` and `/xyz`:

```js
app.use(/\/abc|\/xyz/, (req, res, next) => {
  next()
})
```

</td>
</tr>

<tr>
<td>Array</td>
<td markdown="1">
This will match paths starting with `/abcd`, `/xyza`, `/lmn`, and `/pqr`:

```js
app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], (req, res, next) => {
  next()
})
```

</td>
</tr>

</tbody>

</table>
</div>

##### Middleware callback function examples

The following table provides some simple examples of middleware functions that
can be used as the `callback` argument to `app.use()`, `app.METHOD()`, and `app.all()`.
Even though the examples are for `app.use()`, they are also valid for `app.use()`, `app.METHOD()`, and `app.all()`.

<table class="doctable">

<thead>
<tr>
<th>Usage</th>
<th>Example</th>
</tr>
</thead>
<tbody>

<tr>
<td>Single Middleware</td>
<td markdown="1">
You can define and mount a middleware function locally.

```js
app.use((req, res, next) => {
  next()
})
```

A router is valid middleware.

```js
const router = express.Router()
router.get('/', (req, res, next) => {
  next()
})
app.use(router)
```

An Express app is valid middleware.
```js
const subApp = express()
subApp.get('/', (req, res, next) => {
  next()
})
app.use(subApp)
```

</td>
</tr>

<tr>
<td>Series of Middleware</td>
<td markdown="1">
You can specify more than one middleware function at the same mount path.

```js
const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use(r1, r2)
```

</td>
</tr>

<tr>
<td>Array</td>
<td markdown="1">
Use an array to group middleware logically.

```js
const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use([r1, r2])
```

</td>
</tr>

<tr>
<td>Combination</td>
<td markdown="1">
You can combine all the above ways of mounting middleware.

```js
function mw1 (req, res, next) { next() }
function mw2 (req, res, next) { next() }

const r1 = express.Router()
r1.get('/', (req, res, next) => { next() })

const r2 = express.Router()
r2.get('/', (req, res, next) => { next() })

const subApp = express()
subApp.get('/', (req, res, next) => { next() })

app.use(mw1, [mw2, r1, r2], subApp)
```

</td>
</tr>

</tbody>

</table>

Following are some examples of using the [express.static](/{{page.lang}}/guide/using-middleware.html#middleware.built-in)
middleware in an Express app.

Serve static content for the app from the "public" directory in the application directory:

```js
// GET /style.css etc
app.use(express.static(path.join(__dirname, 'public')))
```

Mount the middleware at "/static" to serve static content only when their request path is prefixed with "/static":

```js
// GET /static/style.css etc.
app.use('/static', express.static(path.join(__dirname, 'public')))
```

Disable logging for static content requests by loading the logger middleware after the static middleware:

```js
app.use(express.static(path.join(__dirname, 'public')))
app.use(logger())
```

Serve static files from multiple directories, but give precedence to "./public" over the others:

```js
app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
```

</section>

## Request

The `req` object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention,
the object is always referred to as `req` (and the HTTP response is `res`) but its actual name is determined
by the parameters to the callback function in which you're working.

For example:

```js
app.get('/user/:id', (req, res) => {
  res.send(`user ${req.params.id}`)
})
```

But you could just as well have:

```js
app.get('/user/:id', (request, response) => {
  response.send(`user ${request.params.id}`)
})
```

The `req` object is an enhanced version of Node's own request object
and supports all [built-in fields and methods](https://nodejs.org/api/http.html#http_class_http_incomingmessage).

### Properties

:::caution
In Express 4, `req.files` is no longer available on the `req` object by default. To access uploaded files
on the `req.files` object, use multipart-handling middleware like [busboy](https://www.npmjs.
com/package/busboy), [multer](https://www.npmjs.com/package/multer),
[formidable](https://www.npmjs.com/package/formidable),
[multiparty](https://www.npmjs.com/package/multiparty),
[connect-multiparty](https://www.npmjs.com/package/connect-multiparty),
or [pez](https://www.npmjs.com/package/pez).
:::

<section markdown="1">
#### req.app

This property holds a reference to the instance of the Express application that is using the middleware.

If you follow the pattern in which you create a module that just exports a middleware function
and `require()` it in your main file, then the middleware can access the Express instance via `req.app`

For example:

```js
// index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
```

```js
// mymiddleware.js
module.exports = (req, res) => {
  res.send(`The views directory is ${req.app.get('views')}`)
}
```

</section>

<section markdown="1">
#### req.baseUrl

The URL path on which a router instance was mounted.

The `req.baseUrl` property is similar to the [mountpath](#app.mountpath) property of the `app` object,
except `app.mountpath` returns the matched path pattern(s).

For example:

```js
const greet = express.Router()

greet.get('/jp', (req, res) => {
  console.log(req.baseUrl) // /greet
  res.send('Konichiwa!')
})

app.use('/greet', greet) // load the router on '/greet'
```

Even if you use a path pattern or a set of path patterns to load the router,
the `baseUrl` property returns the matched string, not the pattern(s). In the
following example, the `greet` router is loaded on two path patterns.

```js
app.use(['/gre+t', '/hel{2}o'], greet) // load the router on '/gre+t' and '/hel{2}o'
```

When a request is made to `/greet/jp`, `req.baseUrl` is "/greet". When a request is
made to `/hello/jp`, `req.baseUrl` is "/hello".

</section>

<section markdown="1">
#### req.body

Contains key-value pairs of data submitted in the request body.
By default, it is `undefined`, and is populated when you use body-parsing middleware such
as [body-parser](https://www.npmjs.org/package/body-parser) and [multer](https://www.npmjs.org/package/multer).

:::danger
As `req.body`'s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, `req.body.foo.toString()` may fail in multiple ways, for example `foo` may not be there or may not be a string, and `toString` may not be a function and instead a string or other user-input.
:::

The following example shows how to use body-parsing middleware to populate `req.body`.

```js
const app = require('express')()
const bodyParser = require('body-parser')
const multer = require('multer') // v1.0.5
const upload = multer() // for parsing multipart/form-data

app.use(bodyParser.json()) // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', upload.array(), (req, res, next) => {
  console.log(req.body)
  res.json(req.body)
})
```

</section>

<section markdown="1">
#### req.cookies

When using [cookie-parser](https://www.npmjs.com/package/cookie-parser) middleware, this property is an object that
contains cookies sent by the request. If the request contains no cookies, it defaults to `{}`.

```js
// Cookie: name=tj
console.dir(req.cookies.name)
// => "tj"
```

If the cookie has been signed, you have to use [req.signedCookies](#req.signedCookies).

For more information, issues, or concerns, see [cookie-parser](https://github.com/expressjs/cookie-parser).

</section>

<section markdown="1">
<h3 id='req.fresh'>req.fresh</h3>

When the response is still "fresh" in the client's cache `true` is returned, otherwise `false` is returned to indicate that the client cache is now stale and the full response should be sent.

When a client sends the `Cache-Control: no-cache` request header to indicate an end-to-end reload request, this module will return `false` to make handling these requests transparent.

Further details for how cache validation works can be found in the
[HTTP/1.1 Caching Specification](https://tools.ietf.org/html/rfc7234).

```js
console.dir(req.fresh)
// => true
```

</section>

<section markdown="1">
#### req.host

Contains the host derived from the `Host` HTTP header.

When the [`trust proxy` setting](api.html#app.settings.table)
does not evaluate to `false`, this property will instead get the value
from the `X-Forwarded-Host` header field. This header can be set by
the client or by the proxy.

If there is more than one `X-Forwarded-Host` header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

```js
// Host: "example.com:3000"
console.dir(req.host)
// => 'example.com:3000'

// Host: "[::1]:3000"
console.dir(req.host)
// => '[::1]:3000'
```

</section>

<section markdown="1">
#### req.hostname

Contains the hostname derived from the `Host` HTTP header.

When the [`trust proxy` setting](/5x/api.html#trust.proxy.options.table)
does not evaluate to `false`, this property will instead get the value
from the `X-Forwarded-Host` header field. This header can be set by
the client or by the proxy.

If there is more than one `X-Forwarded-Host` header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

:::note
Prior to Express v4.17.0, the `X-Forwarded-Host` could not contain multiple
values or be present more than once.
:::

```js
// Host: "example.com:3000"
console.dir(req.hostname)
// => 'example.com'
```

</section>

<section markdown="1">
#### req.ip

Contains the remote IP address of the request.

When the [`trust proxy` setting](/5x/api.html#trust.proxy.options.table) does not evaluate to `false`,
the value of this property is derived from the left-most entry in the
`X-Forwarded-For` header. This header can be set by the client or by the proxy.

```js
console.dir(req.ip)
// => "127.0.0.1"
```

</section>

<section markdown="1">
#### req.ips

When the [`trust proxy` setting](/5x/api.html#trust.proxy.options.table) does not evaluate to `false`,
this property contains an array of IP addresses
specified in the `X-Forwarded-For` request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

For example, if `X-Forwarded-For` is `client, proxy1, proxy2`, `req.ips` would be
`["client", "proxy1", "proxy2"]`, where `proxy2` is the furthest downstream.

</section>

<section markdown="1">
#### req.method

Contains a string corresponding to the HTTP method of the request:
`GET`, `POST`, `PUT`, and so on.

</section>

<section markdown="1">
#### req.originalUrl

:::caution
`req.url` is not a native Express property, it is inherited from Node's [http module](https://nodejs.org/api/http.html#http_message_url).
:::

This property is much like `req.url`; however, it retains the original request URL,
allowing you to rewrite `req.url` freely for internal routing purposes. For example,
the "mounting" feature of [app.use()](#app.use) will rewrite `req.url` to strip the mount point.

```js
// GET /search?q=something
console.dir(req.originalUrl)
// => "/search?q=something"
```

`req.originalUrl` is available both in middleware and router objects, and is a
combination of `req.baseUrl` and `req.url`. Consider following example:

```js
// GET 'http://www.example.com/admin/new?sort=desc'
app.use('/admin', (req, res, next) => {
  console.dir(req.originalUrl) // '/admin/new?sort=desc'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
```

</section>

<section markdown="1">
#### req.params

This property is an object containing properties mapped to the [named route "parameters"](/guide/routing.html#route-parameters). For example, if you have the route `/user/:name`, then the "name" property is available as `req.params.name`. This object defaults to `{}`.

```js
// GET /user/tj
console.dir(req.params.name)
// => "tj"
```

When you use a regular expression for the route definition, capture groups are provided in the array using `req.params[n]`, where `n` is the n<sup>th</sup> capture group. This rule is applied to unnamed wild card matches with string routes such as `/file/*`:

```js
// GET /file/javascripts/jquery.js
console.dir(req.params[0])
// => "javascripts/jquery.js"
```

If you need to make changes to a key in `req.params`, use the [app.param](/5x/api.html#app.param) handler. Changes are applicable only to [parameters](/guide/routing.html#route-parameters) already defined in the route path.

Any changes made to the `req.params` object in a middleware or route handler will be reset.

:::note
Express automatically decodes the values in `req.params` (using `decodeURIComponent`).
:::

</section>

<section markdown="1">
#### req.path

Contains the path part of the request URL.

```js
// example.com/users?sort=desc
console.dir(req.path)
// => "/users"
```

:::note
When called from a middleware, the mount point is not included in `req.path`. See [app.use()](/5x/api.html#app.use) for more details.
:::

</section>

<section markdown="1">
#### req.protocol

Contains the request protocol string: either `http` or (for TLS requests) `https`.

When the [`trust proxy` setting](#trust.proxy.options.table) does not evaluate to `false`,
this property will use the value of the `X-Forwarded-Proto` header field if present.
This header can be set by the client or by the proxy.

```js
console.dir(req.protocol)
// => "http"
```

</section>

<section markdown="1">
#### req.query

This property is an object containing a property for each query string parameter in the route.
When [query parser](#app.settings.table) is set to disabled, it is an empty object `{}`, otherwise it is the result of the configured query parser.

:::danger
As `req.query`'s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, `req.query.foo.toString()` may fail in multiple ways, for example `foo` may not be there or may not be a string, and `toString` may not be a function and instead a string or other user-input.
:::

The value of this property can be configured with the [query parser application setting](#app.settings.table) to work how your application needs it. A very popular query string parser is the [`qs` module](https://www.npmjs.org/package/qs), and this is used by default. The `qs` module is very configurable with many settings, and it may be desirable to use different settings than the default to populate `req.query`:

```js
const qs = require('qs')
app.set('query parser',
  (str) => qs.parse(str, { /* custom options */ }))
```

Check out the [query parser application setting](#app.settings.table) documentation for other customization options.

</section>

<section markdown="1">
#### req.res

This property holds a reference to the <a href="#res">response object</a>
that relates to this request object.

</section>

<section markdown="1">
#### req.route

Contains the currently-matched route, a string. For example:

```js
app.get('/user/:id?', (req, res) => {
  console.log(req.route)
  res.send('GET')
})
```

Example output from the previous snippet:

```json
{ path: '/user/:id?',
  stack:
   [ { handle: [Function: userIdHandler],
       name: 'userIdHandler',
       params: undefined,
       path: undefined,
       keys: [],
       regexp: /^\/?$/i,
       method: 'get' } ],
  methods: { get: true }
}
```

</section>

<section markdown="1">
#### req.secure
 
A Boolean property that is true if a TLS connection is established. Equivalent to the following:

```js
req.protocol === 'https'
```

</section>

<section markdown="1">
#### req.signedCookies

When using [cookie-parser](https://www.npmjs.com/package/cookie-parser) middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
`req.cookie` values (which are easy to spoof). Note that signing a cookie does not make it "hidden"
or encrypted; but simply prevents tampering (because the secret used to sign is private).

If no signed cookies are sent, the property defaults to `{}`.

```js
// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => "tobi"
```

For more information, issues, or concerns, see [cookie-parser](https://github.com/expressjs/cookie-parser).

</section>

<section markdown="1">
#### req.stale

Indicates whether the request is "stale," and is the opposite of `req.fresh`.
For more information, see [req.fresh](#req.fresh).

```js
console.dir(req.stale)
// => true
```

</section>

<section markdown="1">
#### req.subdomains

An array of subdomains in the domain name of the request.

```js
// Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ["ferrets", "tobi"]
```

The application property `subdomain offset`, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using [app.set](/5x/api.html#app.set).

</section>

<section markdown="1">
#### req.xhr

A Boolean property that is `true` if the request's `X-Requested-With` header field is
"XMLHttpRequest", indicating that the request was issued by a client library such as jQuery.

```js
console.dir(req.xhr)
// => true
```

</section>

### Methods

<section markdown="1">
#### req.accepts(types)

Checks if the specified content types are acceptable, based on the request's `Accept` HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
`false` (in which case, the application should respond with `406 "Not Acceptable"`).

The `type` value may be a single MIME type string (such as "application/json"),
an extension name such as "json", a comma-delimited list, or an array. For a
list or array, the method returns the *best* match (if any).

```js
// Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
```

For more information, or if you have issues or concerns, see [accepts](https://github.com/expressjs/accepts).

</section>

<section markdown="1">
#### req.acceptsCharsets(charset [, ...])

Returns the first accepted charset of the specified character sets,
based on the request's `Accept-Charset` HTTP header field.
If none of the specified charsets is accepted, returns `false`.

For more information, or if you have issues or concerns, see [accepts](https://github.com/expressjs/accepts).

</section>

<section markdown="1">
#### req.acceptsEncodings(encoding [, ...])

Returns the first accepted encoding of the specified encodings,
based on the request's `Accept-Encoding` HTTP header field.
If none of the specified encodings is accepted, returns `false`.

For more information, or if you have issues or concerns, see [accepts](https://github.com/expressjs/accepts).

</section>

<section markdown="1">
#### req.acceptsLanguages(lang [, ...])

Returns the first accepted language of the specified languages,
based on the request's `Accept-Language` HTTP header field.
If none of the specified languages is accepted, returns `false`.

For more information, or if you have issues or concerns, see [accepts](https://github.com/expressjs/accepts).

</section>

<section markdown="1">
#### req.get(field)

Returns the specified HTTP request header field (case-insensitive match).
The `Referrer` and `Referer` fields are interchangeable.

```js
req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
```

Aliased as `req.header(field)`.

</section>

<section markdown="1">
#### req.is(type)

Returns the matching content type if the incoming request's "Content-Type" HTTP header field
matches the MIME type specified by the `type` parameter. If the request has no body, returns `null`.
Returns `false` otherwise.

```js
// With Content-Type: text/html; charset=utf-8
req.is('html') // => 'html'
req.is('text/html') // => 'text/html'
req.is('text/*') // => 'text/*'

// When Content-Type is application/json
req.is('json') // => 'json'
req.is('application/json') // => 'application/json'
req.is('application/*') // => 'application/*'

req.is('html')
// => false
```

For more information, or if you have issues or concerns, see [type-is](https://github.com/expressjs/type-is).

</section>

<section markdown="1">
#### req.range(size[, options])

`Range` header parser.

The `size` parameter is the maximum size of the resource.

The `options` parameter is an object that can have the following properties.

| Property    | Type |  Description                                                     |
|-------------|-------------------------------------------------------------------------|
| `combine`   | Boolean | Specify if overlapping & adjacent ranges should be combined, defaults to `false`. When `true`, ranges will be combined and returned as if they were specified that way in the header.

An array of ranges will be returned or negative numbers indicating an error parsing.

* `-2` signals a malformed header string
* `-1` signals an unsatisfiable range

```js
// parse header from request
const range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach((r) => {
    // do something with r.start and r.end
  })
}
```

</section>

